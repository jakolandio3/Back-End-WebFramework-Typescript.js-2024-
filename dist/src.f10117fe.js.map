{"version":3,"sources":["src/models/User.ts","src/index.ts"],"names":[],"mappings":";;;;;ACAA,IAAA,MAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAEA,ADKA,ICLM,KAAK,GAAG,IAAI,MAAA,CAAA,IAAI,CAAC;ADOvB,ECPyB,IAAI,EAAE,OAAO;ADStC,ECTwC,EDSxC,CCT2C,EAAE,CDS7C,GAAA,aAAA,YAAA;ACT+C,CAAE,CAAC,ADYjD;ACVD,EDYC,GCZI,CAAC,GAAG,CAAC,CDYT,IAAA,CAAoB,IAAe,EAAA;ECZxB,EDYS,ECZL,EAAE,ADYG,CAAA,IAAI,GAAJ,IAAI;ACZA,CAAE,CAAC,EDQ3B;ACPD,IDQC,CCRI,CAAC,EDQL,CCRQ,ADQR,CCRS,KDQH,GAAkC,CAAA,CAAE;ECR/B,ADW2B,GCXxB,EAAE;AAAE,CAAE,CAAC,ADarB,IAAA,CAAA,SAAA,CAAA,GAAG,GAAH,UAAI,QAAgB,EAAA;ACXrB,IDYE,GCZK,CAAC,GAAG,ADYF,CCZG,GDYC,CAAC,CCZG,CAAC,EDYA,CCZG,ADYF,CCZG,MAAM,CAAC,ADYF,CCZG,ADYF;ACX5B,EDYC,CAAC,ICZK,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAE7B,EDYC,GCZI,CAAC,ADYL,CAAA,CCZO,CAAC,OAAO,ADYf,CAAA,CCZiB,EDYd,GAAH,OCZiB,GDYb,UAAqB,EAAA;ECZF,EDatB,KCbsB,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC;AAA1B,CAA0B,CAAC,EDcjD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC;ACbtC,EDcC,CAAC,ECdG,CAAC,EAAE,CAAC,OAAO,EAAE,YAAA;EAAM,ADgBvB,OChBuB,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC;AAA1B,CAA0B,CAAC,ADiBlD,IAAA,CAAA,SAAA,CAAA,EAAE,GAAF,UAAG,SAAiB,EAAE,QAAkB,EAAA;ACfzC,IDgBE,IAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE;ACf/C,IDgBE,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC;ACfzB,IDgBE,CChBG,CAAC,EDgBA,CAAC,IChBM,CAAC,CDgBD,CAAC,KChBO,CAAC,GDgBC,CAAC,GAAG,QAAQ;IACjC;EACD,CAAC;EAED;EACA,IAAA,CAAA,SAAA,CAAA,OAAO,GAAP,UAAQ,SAAiB,EAAA;IACxB;IACA,IAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;IAEvC,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;MACvC;;IAED,QAAQ,CAAC,OAAO,CAAC,UAAC,QAAQ,EAAA;MAAK,OAAA,QAAQ,CAAA,CAAE;IAAV,CAAU,CAAC;IAC1C;EACD,CAAC;EACF,OAAA,IAAC;AAAD,CAnCA,CAAA,CAAA;AAAa,OAAA,CAAA,IAAA,GAAA,IAAA","file":"src.f10117fe.js","sourceRoot":"..","sourcesContent":["interface UserProps {\n\tname?: string;\n\tage?: number;\n\t//here im making the props optional in the object so you can change one item\n}\n\ntype Callback = () => void;\n// setting up a type alias so it doesnt get too confusing in the code\n\n//making a lot of these properties optional means we can allow empty classes to be made and assign these values later\n\nexport class User {\n\t//adding a property for the events\n\tevents: { [key: string]: Callback[] } = {};\n\t// this is just stating that the keys are unknown on creation but guarantee they will be strings and will always point to an array of callbacks\n\n\tconstructor(private data: UserProps) {}\n\n\tget(propName: string): number | string {\n\t\treturn this.data[propName];\n\t}\n\n\tset(updateProp: UserProps): void {\n\t\t//Object assign method here copy pastes the data from the passed in argument and copy pastes it to this.data (UserProps type makes sure it is passed an object with name:str and age:num)\n\t\tObject.assign(this.data, updateProp);\n\t}\n\n\t//this will be a list of events to call on render/change/update\n\ton(eventName: string, callback: Callback): void {\n\t\tconst handlers = this.events[eventName] || [];\n\t\thandlers.push(callback);\n\t\tthis.events[eventName] = handlers;\n\t\t//take the array at the event name key and push the new array or create one\n\t}\n\n\t// adding the event listners to desired type\n\ttrigger(eventName: string): void {\n\t\t// this.events[eventName]?.map((event) => event()); this is my initial way\n\t\tconst handlers = this.events[eventName];\n\n\t\tif (!handlers || handlers.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\thandlers.forEach((callback) => callback());\n\t\t//essentially my code did the same without assigning the variable to handlers\n\t}\n}\n","import { User } from './models/User';\n\nconst Jakob = new User({ name: 'jakob', age: 28 });\n\nJakob.set({ name: 'jakos' });\nJakob.set({ age: 68 });\n\nconsole.log(Jakob.get('name'));\nconsole.log(Jakob.get('age'));\n\nJakob.on('click', () => console.log('ive clicked'));\nJakob.on('click', () => console.log('ive clocked'));\n\n// Jakob.events['click'][0]();\n// Jakob.events['click'][1]();\nJakob.trigger('click');\n"]}